// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for zookeeperreceiver metrics.
type MetricsSettings struct {
	ZookeeperApproximateDateSize   MetricSettings `mapstructure:"zookeeper.approximate_date_size"`
	ZookeeperConnectionsAlive      MetricSettings `mapstructure:"zookeeper.connections_alive"`
	ZookeeperEphemeralNodes        MetricSettings `mapstructure:"zookeeper.ephemeral_nodes"`
	ZookeeperFollowers             MetricSettings `mapstructure:"zookeeper.followers"`
	ZookeeperFsyncThresholdExceeds MetricSettings `mapstructure:"zookeeper.fsync_threshold_exceeds"`
	ZookeeperLatencyAvg            MetricSettings `mapstructure:"zookeeper.latency.avg"`
	ZookeeperLatencyMax            MetricSettings `mapstructure:"zookeeper.latency.max"`
	ZookeeperLatencyMin            MetricSettings `mapstructure:"zookeeper.latency.min"`
	ZookeeperMaxFileDescriptors    MetricSettings `mapstructure:"zookeeper.max_file_descriptors"`
	ZookeeperOpenFileDescriptors   MetricSettings `mapstructure:"zookeeper.open_file_descriptors"`
	ZookeeperOutstandingRequests   MetricSettings `mapstructure:"zookeeper.outstanding_requests"`
	ZookeeperPacketsReceived       MetricSettings `mapstructure:"zookeeper.packets.received"`
	ZookeeperPacketsSent           MetricSettings `mapstructure:"zookeeper.packets.sent"`
	ZookeeperPendingSyncs          MetricSettings `mapstructure:"zookeeper.pending_syncs"`
	ZookeeperSyncedFollowers       MetricSettings `mapstructure:"zookeeper.synced_followers"`
	ZookeeperWatches               MetricSettings `mapstructure:"zookeeper.watches"`
	ZookeeperZnodes                MetricSettings `mapstructure:"zookeeper.znodes"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		ZookeeperApproximateDateSize: MetricSettings{
			Enabled: true,
		},
		ZookeeperConnectionsAlive: MetricSettings{
			Enabled: true,
		},
		ZookeeperEphemeralNodes: MetricSettings{
			Enabled: true,
		},
		ZookeeperFollowers: MetricSettings{
			Enabled: true,
		},
		ZookeeperFsyncThresholdExceeds: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyAvg: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyMax: MetricSettings{
			Enabled: true,
		},
		ZookeeperLatencyMin: MetricSettings{
			Enabled: true,
		},
		ZookeeperMaxFileDescriptors: MetricSettings{
			Enabled: true,
		},
		ZookeeperOpenFileDescriptors: MetricSettings{
			Enabled: true,
		},
		ZookeeperOutstandingRequests: MetricSettings{
			Enabled: true,
		},
		ZookeeperPacketsReceived: MetricSettings{
			Enabled: true,
		},
		ZookeeperPacketsSent: MetricSettings{
			Enabled: true,
		},
		ZookeeperPendingSyncs: MetricSettings{
			Enabled: true,
		},
		ZookeeperSyncedFollowers: MetricSettings{
			Enabled: true,
		},
		ZookeeperWatches: MetricSettings{
			Enabled: true,
		},
		ZookeeperZnodes: MetricSettings{
			Enabled: true,
		},
	}
}

type metricZookeeperApproximateDateSize struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.approximate_date_size metric with initial data.
func (m *metricZookeeperApproximateDateSize) init() {
	m.data.SetName("zookeeper.approximate_date_size")
	m.data.SetDescription("Size of data in bytes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperApproximateDateSize) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperApproximateDateSize) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperApproximateDateSize) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperApproximateDateSize(settings MetricSettings) metricZookeeperApproximateDateSize {
	m := metricZookeeperApproximateDateSize{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperConnectionsAlive struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.connections_alive metric with initial data.
func (m *metricZookeeperConnectionsAlive) init() {
	m.data.SetName("zookeeper.connections_alive")
	m.data.SetDescription("Number of active clients connected to a ZooKeeper server.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperConnectionsAlive) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperConnectionsAlive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperConnectionsAlive) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperConnectionsAlive(settings MetricSettings) metricZookeeperConnectionsAlive {
	m := metricZookeeperConnectionsAlive{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperEphemeralNodes struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.ephemeral_nodes metric with initial data.
func (m *metricZookeeperEphemeralNodes) init() {
	m.data.SetName("zookeeper.ephemeral_nodes")
	m.data.SetDescription("Number of ephemeral nodes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperEphemeralNodes) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperEphemeralNodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperEphemeralNodes) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperEphemeralNodes(settings MetricSettings) metricZookeeperEphemeralNodes {
	m := metricZookeeperEphemeralNodes{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFollowers struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.followers metric with initial data.
func (m *metricZookeeperFollowers) init() {
	m.data.SetName("zookeeper.followers")
	m.data.SetDescription("The number of followers in sync with the leader. Only exposed by the leader.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperFollowers) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFollowers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFollowers) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFollowers(settings MetricSettings) metricZookeeperFollowers {
	m := metricZookeeperFollowers{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFsyncThresholdExceeds struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.fsync_threshold_exceeds metric with initial data.
func (m *metricZookeeperFsyncThresholdExceeds) init() {
	m.data.SetName("zookeeper.fsync_threshold_exceeds")
	m.data.SetDescription("Number of times fsync duration has exceeded warning threshold.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperFsyncThresholdExceeds) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFsyncThresholdExceeds) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFsyncThresholdExceeds) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFsyncThresholdExceeds(settings MetricSettings) metricZookeeperFsyncThresholdExceeds {
	m := metricZookeeperFsyncThresholdExceeds{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyAvg struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.avg metric with initial data.
func (m *metricZookeeperLatencyAvg) init() {
	m.data.SetName("zookeeper.latency.avg")
	m.data.SetDescription("Average time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperLatencyAvg) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyAvg) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyAvg(settings MetricSettings) metricZookeeperLatencyAvg {
	m := metricZookeeperLatencyAvg{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyMax struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.max metric with initial data.
func (m *metricZookeeperLatencyMax) init() {
	m.data.SetName("zookeeper.latency.max")
	m.data.SetDescription("Maximum time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperLatencyMax) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyMax) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyMax(settings MetricSettings) metricZookeeperLatencyMax {
	m := metricZookeeperLatencyMax{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyMin struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.min metric with initial data.
func (m *metricZookeeperLatencyMin) init() {
	m.data.SetName("zookeeper.latency.min")
	m.data.SetDescription("Minimum time in milliseconds for requests to be processed.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperLatencyMin) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyMin) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyMin) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyMin(settings MetricSettings) metricZookeeperLatencyMin {
	m := metricZookeeperLatencyMin{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperMaxFileDescriptors struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.max_file_descriptors metric with initial data.
func (m *metricZookeeperMaxFileDescriptors) init() {
	m.data.SetName("zookeeper.max_file_descriptors")
	m.data.SetDescription("Maximum number of file descriptors that a ZooKeeper server can open.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperMaxFileDescriptors) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperMaxFileDescriptors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperMaxFileDescriptors) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperMaxFileDescriptors(settings MetricSettings) metricZookeeperMaxFileDescriptors {
	m := metricZookeeperMaxFileDescriptors{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperOpenFileDescriptors struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.open_file_descriptors metric with initial data.
func (m *metricZookeeperOpenFileDescriptors) init() {
	m.data.SetName("zookeeper.open_file_descriptors")
	m.data.SetDescription("Number of file descriptors that a ZooKeeper server has open.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperOpenFileDescriptors) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperOpenFileDescriptors) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperOpenFileDescriptors) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperOpenFileDescriptors(settings MetricSettings) metricZookeeperOpenFileDescriptors {
	m := metricZookeeperOpenFileDescriptors{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperOutstandingRequests struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.outstanding_requests metric with initial data.
func (m *metricZookeeperOutstandingRequests) init() {
	m.data.SetName("zookeeper.outstanding_requests")
	m.data.SetDescription("Number of currently executing requests.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperOutstandingRequests) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperOutstandingRequests) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperOutstandingRequests) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperOutstandingRequests(settings MetricSettings) metricZookeeperOutstandingRequests {
	m := metricZookeeperOutstandingRequests{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperPacketsReceived struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.packets.received metric with initial data.
func (m *metricZookeeperPacketsReceived) init() {
	m.data.SetName("zookeeper.packets.received")
	m.data.SetDescription("Number of ZooKeeper packets received by a server.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperPacketsReceived) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperPacketsReceived) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperPacketsReceived) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperPacketsReceived(settings MetricSettings) metricZookeeperPacketsReceived {
	m := metricZookeeperPacketsReceived{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperPacketsSent struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.packets.sent metric with initial data.
func (m *metricZookeeperPacketsSent) init() {
	m.data.SetName("zookeeper.packets.sent")
	m.data.SetDescription("Number of ZooKeeper packets sent by a server.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricZookeeperPacketsSent) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperPacketsSent) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperPacketsSent) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperPacketsSent(settings MetricSettings) metricZookeeperPacketsSent {
	m := metricZookeeperPacketsSent{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperPendingSyncs struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.pending_syncs metric with initial data.
func (m *metricZookeeperPendingSyncs) init() {
	m.data.SetName("zookeeper.pending_syncs")
	m.data.SetDescription("The number of pending syncs from the followers. Only exposed by the leader.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperPendingSyncs) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperPendingSyncs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperPendingSyncs) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperPendingSyncs(settings MetricSettings) metricZookeeperPendingSyncs {
	m := metricZookeeperPendingSyncs{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperSyncedFollowers struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.synced_followers metric with initial data.
func (m *metricZookeeperSyncedFollowers) init() {
	m.data.SetName("zookeeper.synced_followers")
	m.data.SetDescription("The number of followers in sync with the leader. Only exposed by the leader.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperSyncedFollowers) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperSyncedFollowers) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperSyncedFollowers) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperSyncedFollowers(settings MetricSettings) metricZookeeperSyncedFollowers {
	m := metricZookeeperSyncedFollowers{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperWatches struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.watches metric with initial data.
func (m *metricZookeeperWatches) init() {
	m.data.SetName("zookeeper.watches")
	m.data.SetDescription("Number of watches placed on Z-Nodes on a ZooKeeper server.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperWatches) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperWatches) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperWatches) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperWatches(settings MetricSettings) metricZookeeperWatches {
	m := metricZookeeperWatches{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperZnodes struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.znodes metric with initial data.
func (m *metricZookeeperZnodes) init() {
	m.data.SetName("zookeeper.znodes")
	m.data.SetDescription("Number of z-nodes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricZookeeperZnodes) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperZnodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperZnodes) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperZnodes(settings MetricSettings) metricZookeeperZnodes {
	m := metricZookeeperZnodes{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                            pdata.Timestamp
	metricZookeeperApproximateDateSize   metricZookeeperApproximateDateSize
	metricZookeeperConnectionsAlive      metricZookeeperConnectionsAlive
	metricZookeeperEphemeralNodes        metricZookeeperEphemeralNodes
	metricZookeeperFollowers             metricZookeeperFollowers
	metricZookeeperFsyncThresholdExceeds metricZookeeperFsyncThresholdExceeds
	metricZookeeperLatencyAvg            metricZookeeperLatencyAvg
	metricZookeeperLatencyMax            metricZookeeperLatencyMax
	metricZookeeperLatencyMin            metricZookeeperLatencyMin
	metricZookeeperMaxFileDescriptors    metricZookeeperMaxFileDescriptors
	metricZookeeperOpenFileDescriptors   metricZookeeperOpenFileDescriptors
	metricZookeeperOutstandingRequests   metricZookeeperOutstandingRequests
	metricZookeeperPacketsReceived       metricZookeeperPacketsReceived
	metricZookeeperPacketsSent           metricZookeeperPacketsSent
	metricZookeeperPendingSyncs          metricZookeeperPendingSyncs
	metricZookeeperSyncedFollowers       metricZookeeperSyncedFollowers
	metricZookeeperWatches               metricZookeeperWatches
	metricZookeeperZnodes                metricZookeeperZnodes
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                            pdata.NewTimestampFromTime(time.Now()),
		metricZookeeperApproximateDateSize:   newMetricZookeeperApproximateDateSize(settings.ZookeeperApproximateDateSize),
		metricZookeeperConnectionsAlive:      newMetricZookeeperConnectionsAlive(settings.ZookeeperConnectionsAlive),
		metricZookeeperEphemeralNodes:        newMetricZookeeperEphemeralNodes(settings.ZookeeperEphemeralNodes),
		metricZookeeperFollowers:             newMetricZookeeperFollowers(settings.ZookeeperFollowers),
		metricZookeeperFsyncThresholdExceeds: newMetricZookeeperFsyncThresholdExceeds(settings.ZookeeperFsyncThresholdExceeds),
		metricZookeeperLatencyAvg:            newMetricZookeeperLatencyAvg(settings.ZookeeperLatencyAvg),
		metricZookeeperLatencyMax:            newMetricZookeeperLatencyMax(settings.ZookeeperLatencyMax),
		metricZookeeperLatencyMin:            newMetricZookeeperLatencyMin(settings.ZookeeperLatencyMin),
		metricZookeeperMaxFileDescriptors:    newMetricZookeeperMaxFileDescriptors(settings.ZookeeperMaxFileDescriptors),
		metricZookeeperOpenFileDescriptors:   newMetricZookeeperOpenFileDescriptors(settings.ZookeeperOpenFileDescriptors),
		metricZookeeperOutstandingRequests:   newMetricZookeeperOutstandingRequests(settings.ZookeeperOutstandingRequests),
		metricZookeeperPacketsReceived:       newMetricZookeeperPacketsReceived(settings.ZookeeperPacketsReceived),
		metricZookeeperPacketsSent:           newMetricZookeeperPacketsSent(settings.ZookeeperPacketsSent),
		metricZookeeperPendingSyncs:          newMetricZookeeperPendingSyncs(settings.ZookeeperPendingSyncs),
		metricZookeeperSyncedFollowers:       newMetricZookeeperSyncedFollowers(settings.ZookeeperSyncedFollowers),
		metricZookeeperWatches:               newMetricZookeeperWatches(settings.ZookeeperWatches),
		metricZookeeperZnodes:                newMetricZookeeperZnodes(settings.ZookeeperZnodes),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user settings, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	mb.metricZookeeperApproximateDateSize.emit(metrics)
	mb.metricZookeeperConnectionsAlive.emit(metrics)
	mb.metricZookeeperEphemeralNodes.emit(metrics)
	mb.metricZookeeperFollowers.emit(metrics)
	mb.metricZookeeperFsyncThresholdExceeds.emit(metrics)
	mb.metricZookeeperLatencyAvg.emit(metrics)
	mb.metricZookeeperLatencyMax.emit(metrics)
	mb.metricZookeeperLatencyMin.emit(metrics)
	mb.metricZookeeperMaxFileDescriptors.emit(metrics)
	mb.metricZookeeperOpenFileDescriptors.emit(metrics)
	mb.metricZookeeperOutstandingRequests.emit(metrics)
	mb.metricZookeeperPacketsReceived.emit(metrics)
	mb.metricZookeeperPacketsSent.emit(metrics)
	mb.metricZookeeperPendingSyncs.emit(metrics)
	mb.metricZookeeperSyncedFollowers.emit(metrics)
	mb.metricZookeeperWatches.emit(metrics)
	mb.metricZookeeperZnodes.emit(metrics)
}

// RecordZookeeperApproximateDateSizeDataPoint adds a data point to zookeeper.approximate_date_size metric.
func (mb *MetricsBuilder) RecordZookeeperApproximateDateSizeDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperApproximateDateSize.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperConnectionsAliveDataPoint adds a data point to zookeeper.connections_alive metric.
func (mb *MetricsBuilder) RecordZookeeperConnectionsAliveDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperConnectionsAlive.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperEphemeralNodesDataPoint adds a data point to zookeeper.ephemeral_nodes metric.
func (mb *MetricsBuilder) RecordZookeeperEphemeralNodesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperEphemeralNodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperFollowersDataPoint adds a data point to zookeeper.followers metric.
func (mb *MetricsBuilder) RecordZookeeperFollowersDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperFollowers.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperFsyncThresholdExceedsDataPoint adds a data point to zookeeper.fsync_threshold_exceeds metric.
func (mb *MetricsBuilder) RecordZookeeperFsyncThresholdExceedsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperFsyncThresholdExceeds.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperLatencyAvgDataPoint adds a data point to zookeeper.latency.avg metric.
func (mb *MetricsBuilder) RecordZookeeperLatencyAvgDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperLatencyAvg.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperLatencyMaxDataPoint adds a data point to zookeeper.latency.max metric.
func (mb *MetricsBuilder) RecordZookeeperLatencyMaxDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperLatencyMax.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperLatencyMinDataPoint adds a data point to zookeeper.latency.min metric.
func (mb *MetricsBuilder) RecordZookeeperLatencyMinDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperLatencyMin.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperMaxFileDescriptorsDataPoint adds a data point to zookeeper.max_file_descriptors metric.
func (mb *MetricsBuilder) RecordZookeeperMaxFileDescriptorsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperMaxFileDescriptors.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperOpenFileDescriptorsDataPoint adds a data point to zookeeper.open_file_descriptors metric.
func (mb *MetricsBuilder) RecordZookeeperOpenFileDescriptorsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperOpenFileDescriptors.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperOutstandingRequestsDataPoint adds a data point to zookeeper.outstanding_requests metric.
func (mb *MetricsBuilder) RecordZookeeperOutstandingRequestsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperOutstandingRequests.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperPacketsReceivedDataPoint adds a data point to zookeeper.packets.received metric.
func (mb *MetricsBuilder) RecordZookeeperPacketsReceivedDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperPacketsReceived.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperPacketsSentDataPoint adds a data point to zookeeper.packets.sent metric.
func (mb *MetricsBuilder) RecordZookeeperPacketsSentDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperPacketsSent.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperPendingSyncsDataPoint adds a data point to zookeeper.pending_syncs metric.
func (mb *MetricsBuilder) RecordZookeeperPendingSyncsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperPendingSyncs.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperSyncedFollowersDataPoint adds a data point to zookeeper.synced_followers metric.
func (mb *MetricsBuilder) RecordZookeeperSyncedFollowersDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperSyncedFollowers.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperWatchesDataPoint adds a data point to zookeeper.watches metric.
func (mb *MetricsBuilder) RecordZookeeperWatchesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperWatches.recordDataPoint(mb.startTime, ts, val)
}

// RecordZookeeperZnodesDataPoint adds a data point to zookeeper.znodes metric.
func (mb *MetricsBuilder) RecordZookeeperZnodesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricZookeeperZnodes.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// ServerState (State of the Zookeeper server (leader, standalone or follower).)
	ServerState string
	// ZkVersion (Zookeeper version of the instance.)
	ZkVersion string
}{
	"server.state",
	"zk.version",
}

// A is an alias for Attributes.
var A = Attributes
